"""
////////////////////////////////////////////////////////////////////////////////////////
//Study Title : A Framework to Assess Cyber-Vulnerabilities of Construction Networks  //
//Authors     : Bharadwaj R.K.Mantha and Borja Garcia de Soto                		  //
//Email       : bmantha at nyu dot edu                                       		  //
//Affiliation : S.M.A.R.T. Construction Research Group,                      		  //
//              Division of Engineering,                                     		  //                 
//			    	New York University Abu Dhabi.                               		  //
//Last updated: June 4, 2020                                                  		  // 
////////////////////////////////////////////////////////////////////////////////////////
"""

# The objective is to simulate the spread of vulnerability in construction networks
# each of the construction entities are represents as agents in the model
# each agent has an initial security state (normal, uncertain, and vulnerable)
# agents interact and change their states based on the rules and conditions 
# inputs are the following
#      agent class (i.e., Project_participants) objects with their id and type (i.e., nodes)
#      connections between agents (i.e., edges)
# outputs are the following
#      summary of nodes and edges in the network
#      security state of each of the agents after performing 0,10,...500 iterations 
# for further details regarding the model, please refer to the paper at (link_to_be_added)

# general imports 
import networkx as nx
import pandas as pd
import numpy
#import matplotlib.pyplot as plt

class construction_agents(object):
    #agent class to define the agents and resp attributes
    # for agent_name abbrevations pls refer to the paper
    # SL - Security Level, High - H and Low - L
    # SS - Security State, Not Compromised - NC,  Compromised - C, and Vulnerable - V
    def __init__(self, agent_name, agent_SL, agent_SS):
        self.agent_name = agent_name
        self.agent_SL = agent_SL
        self.agent_SS = agent_SS

def resetToInitial(list_o,list_d):
    #to reset the updated participant metrics to the original values
    for i in range(len(list_o)):
        list_d[i].agent_SL = list_o[i].agent_SL
        list_d[i].agent_SS = list_o[i].agent_SS
        
def get_all_objects(project_participants):
	# method to get all the instances of the class Project_participants
    result = []
    for each_agent in project_participants:
        temp = []
        temp.append(each_agent.agent_name)
        temp.append(each_agent.agent_SL)
        temp.append(each_agent.agent_SS)
        result.append(temp)
    return result

def get_changes_SL(initial_states,final_states):
    count_changes = 0
    count_h = 0
    count_l = 0
    for i in range(len(final_states)):
        if initial_states[i][0] == final_states[i][0]:
            if initial_states[i][1] != final_states[i][1]:
                count_changes += 1
            if final_states[i][1] == 'H':
                count_h += 1
            if final_states[i][1] == 'L':
                count_l += 1
    return count_changes, count_h,count_l

def get_changes_SS(initial_states,final_states):
    count_changes = 0
    count_NC = 0
    count_C = 0
    count_V = 0
    for i in range(len(final_states)):
        if initial_states[i][0] == final_states[i][0]:
            if initial_states[i][2] != final_states[i][2]:
                count_changes += 1
            if final_states[i][2] == 'NC':
                count_NC += 1
            if final_states[i][2] == 'C':
                count_C += 1   
            if final_states[i][2] == 'V':
                count_V += 1   
    return count_changes,count_NC,count_C,count_V

    
def choose_interaction_CS(Edges, num_interations):
    # outputs list of occurances of edges (=total_iterations) 
    # based on edge_prob  
    Edge_numbers = [i for i in range(len(Edges))]
    edge_probs = get_edge_probs(Edges) #[0.50,0.20,0.20,0.10]
    list_of_edge_numbers = numpy.random.choice(Edge_numbers,num_interations,p=edge_probs)  
    list_of_interactions = []
    for each_no in list_of_edge_numbers:
        list_of_interactions.append(Edges[each_no])
    return list_of_interactions

def get_edge_probs(Edges):
    # gets the probability of each edge based on cs of each edge
    list_of_edge_probs = []
    total_edge_strength = 0
    for each_edge in Edges:
        total_edge_strength = total_edge_strength + each_edge[-1]
    for each_edge in Edges:
        list_of_edge_probs.append(each_edge[-1]/total_edge_strength)     
    if sum(list_of_edge_probs) != 1:
        print("Sum of Probabilities is not 1 but it is:", sum(list_of_edge_probs))
    return list_of_edge_probs

def getPI(agent1, agent2):
    # method to get the PI based on the SS of interacting agents1 and 2
    # agent1 is the originator agent (i.e., vulnerability spread originator)
    # agent2 is the receiver agent 
    if agent1.agent_SS == 'NC':
        return 0.0
    elif agent1.agent_SS == 'C':
        if agent2.agent_SS == 'NC':
            if agent2.agent_SL == 'H':
                return 0.06
            else:
                return 0.12
        elif agent2.agent_SS == 'C':
            if agent2.agent_SL == 'H':
                return 0.08
            else:
                return 0.16
        elif agent2.agent_SS == 'V':
            return 0.0
    elif agent1.agent_SS == 'V':
        if agent2.agent_SS == 'NC':
            if agent2.agent_SL == 'H':
                return 0.10
            else:
                return 0.20
        elif agent2.agent_SS == 'C':
            if agent2.agent_SL == 'H':
                return 0.25
            else:
                return 0.30
        elif agent2.agent_SS == 'V':
            if agent2.agent_SL == 'H':
                return 0.35
            else:
                return 0.0  
            
def interaction_decision(PI):
    # method to decide if the interaction results in a change of vulnerability state
	# True represents a change and False represents a no change scenario 
    return numpy.random.choice([True, False], 1, p=[PI, 1-PI])[0]

def after_interaction(agents_pair):
	# method that performs the interaction and possible change of states
    agent1 = agents_pair[0]
    agent2 = agents_pair[1]
    #print(agent2.agent_name, "before change")
    #print(agent2.agent_SL,agent2.agent_SS)
    if agent1.agent_SS == 'NC':
        pass
    elif agent1.agent_SS == 'C':
        if agent2.agent_SS == 'NC':
            agent2.agent_SS = 'C'
        elif agent2.agent_SS == 'C':
            if agent2.agent_SL == 'H':
                agent2.agent_SL = 'L'
            else:
                agent2.agent_SS = 'V'
        elif agent2.agent_SS == 'V':
            pass
    elif agent1.agent_SS == 'V':
        if agent2.agent_SS == 'NC':
            agent2.agent_SS = 'C'

        elif agent2.agent_SS == 'C':
            if agent2.agent_SL == 'H':
                agent2.agent_SL = 'L'
            else:
                agent2.agent_SS = 'V'
        elif agent2.agent_SS == 'V':
            if agent2.agent_SL == 'H':
                agent2.agent_SL = 'L'
            else:
                pass
    #print(agent2.agent_name, "after change")
    #print(agent2.agent_SL,agent2.agent_SS)

    return None

def run_interaction(Edges, num_interactions,Edges_List_CS):
	# method to run the specified number of iterations and perform the interactions 
    
    for i in range(num_interactions):
        #print("##############################################")
        #print('iteration:',i)
        x = Edges_List_CS[i]
        #print("The pair chosen is:", x[0].agent_name,x[1].agent_name)
        PI = getPI(x[0],x[1])
        #print("The PI value is: ", PI)
        if interaction_decision(PI):
            after_interaction(x)
        else:
            #print("No change")
            pass
    return None
def one_interaction(Edges,num_interactions,Project_participants,df_SL,df_SS,index_name,Edges_List_CS):
	# method that performs one interaction (along with the interaction and possible change of states)
    run_interaction(Edges,num_interactions,Edges_List_CS)
    final_states = get_all_objects(Project_participants)
    for i in range(len(final_states)):
        df_SL.at[index_name,final_states[i][0]] = final_states[i][1]
        df_SS.at[index_name,final_states[i][0]] = final_states[i][2]
    df_SL.at[index_name,'#Changes'] = get_changes_SL(initial_states,final_states)[0]
    df_SL.at[index_name,'#H'] = get_changes_SL(initial_states,final_states)[1]
    df_SL.at[index_name,'#L'] = get_changes_SL(initial_states,final_states)[2]
    
    df_SS.at[index_name,'#Changes'] = get_changes_SS(initial_states,final_states)[0]
    df_SS.at[index_name,'#NC'] = get_changes_SS(initial_states,final_states)[1]
    df_SS.at[index_name,'#C'] = get_changes_SS(initial_states,final_states)[2]
    df_SS.at[index_name,'#V'] = get_changes_SS(initial_states,final_states)[3]   
    
    return df_SL,df_SS

def all_interactions(Edges,Project_participants,df_SL,df_SS,index_list):
	# method to run all the iterations mentioned as per the inputted index_list 
    for each_index in index_list:
        Edges_List_CS = choose_interaction_CS(Edges,each_index[1])
        #print("The edge list generated is:")
        for each_pair in Edges_List_CS:
            pass
            #print(each_pair[0].agent_name,each_pair[1].agent_name)
        one_interaction(Edges,each_index[1],Project_participants,df_SL,df_SS,each_index[0],Edges_List_CS)
        resetToInitial(all_participants_o,Project_participants)
    return df_SL,df_SS


############################### USER INPUTS ##################################

CO  = construction_agents('CO','H','NC')

SM  = construction_agents('SM','H','NC')

MS  = construction_agents('MS','H','NC')
CS  = construction_agents('CS','H','NC')
SS  = construction_agents('SS','H','NC')

EN  = construction_agents('EN','H','NC')

OP  = construction_agents('OP','H','NC')
HE  = construction_agents('HE','L','NC')

DP  = construction_agents('DP','H','V')
DI  = construction_agents('DI','L','NC')
MA  = construction_agents('MA','H','NC')
SU  = construction_agents('SU','H','NC')

CO_o  = construction_agents('CO_o','H','NC')

SM_o  = construction_agents('SM_o','H','NC')

MS_o  = construction_agents('MS_o','H','NC')
CS_o  = construction_agents('CS_o','H','NC')
SS_o  = construction_agents('SS_o','H','NC')

EN_o  = construction_agents('EN_o','H','NC')

OP_o  = construction_agents('OP_o','H','NC')
HE_o  = construction_agents('HE_o','L','NC')

DP_o  = construction_agents('DP_o','H','V')
DI_o  = construction_agents('DI_o','L','NC')
MA_o  = construction_agents('MA_o','H','NC')
SU_o  = construction_agents('SU_o','H','NC')


all_participants_o = [CO_o,SM_o,MS_o,CS_o,SS_o,EN_o,OP_o,HE_o,DP_o,DI_o,MA_o,SU_o]
all_participants = [CO,SM,MS,CS,SS,EN,OP,HE,DP,DI,MA,SU]

Edges_undirected = [
          [CO,SM,4],
          [SM,MS,4],[SM,CS,30],[SM,SS,4],
          [CS,EN,30],[SS,DP,30],
          [EN,OP,30],[EN,HE,30],
          [OP,DP,30],[HE,DP,30],
          [DP,DI,1],[DI,MA,1],[MA,SU,1]
        ]

Edges_directed = [
          [CO,SM,2],[SM,CO,2],
          [SM,MS,2],[MS,SM,2],[SM,CS,15],[CS,SM,15],[SM,SS,2],[SS,SM,2],
          [CS,EN,15],[EN,CS,15],[SS,DP,15],[DP,SS,15],
          [EN,OP,15],[OP,EN,15],[EN,HE,15],[HE,EN,15],
          [OP,DP,15],[DP,OP,15],[HE,DP,15],[DP,HE,15],
          [DP,DI,0.5],[DI,DP,0.5],[DI,MA,0.5],[MA,DI,0.5],[MA,SU,0.5],[SU,MA,0.5]
        ]

edges = [(CO,SM,{'weight':4}),
    (SM,MS,{'weight':4}),(SM,CS,{'weight':30}),(SM,SS,{'weight':4}),
    (CS,EN,{'weight':30}),(SS,DP,{'weight':30}),
    (EN,OP,{'weight':30}),(EN,HE,{'weight':30}),
    (OP,DP,{'weight':30}),(HE,DP,{'weight':30}),
    (DP,DI,{'weight':1}),(DI,MA,{'weight':1}),(MA,SU,{'weight':1})]

"""

all_participants_o = [DP_o,DI_o,MA_o,SU_o]
all_participants = [DP,DI,MA,SU]

Edges_undirected = [[DP,DI,1],[DI,MA,1],[MA,SU,1]]

Edges_directed = [[DP,DI,0.5],[DI,DP,0.5],[DI,MA,0.5],[MA,DI,0.5],[MA,SU,0.5],[SU,MA,0.5]]

edges = [(DP,DI,{'weight':1}),(DI,MA,{'weight':1}),(MA,SU,{'weight':1})]

"""
############################# CODE IMPLEMENTATION ############################
G = nx.Graph()
G.add_nodes_from(all_participants)

G.add_edges_from(edges)

# Creating an empty Dataframe with column and row names only with NaN as elements
df_SL = pd.DataFrame(index =['inter=0', 'inter=10','inter=25','inter=50','inter=75', 'inter=100','inter=125','inter=150','inter=175','inter=200','inter=300','inter=400','inter=500'], columns = ['CO','SM','MS','CS','SS','EN','OP','HE','DP','DI','MA','SU','#Changes','#H','#L'])
df_SS = pd.DataFrame(index =['inter=0', 'inter=10','inter=25','inter=50','inter=75', 'inter=100','inter=125','inter=150','inter=175','inter=200','inter=300','inter=400','inter=500'], columns = ['CO','SM','MS','CS','SS','EN','OP','HE','DP','DI','MA','SU','#Changes','#NC','#C','#V'])

#df_SL = pd.DataFrame(index =['iter=0', 'iter=10','iter=25','iter=50','iter=75', 'iter=100','iter=125','iter=150','iter=175','iter=200','iter=300','iter=400','iter=500'], columns = ['DP','DI','MA','SU'])
#df_SS = pd.DataFrame(index =['iter=0', 'iter=10','iter=25','iter=50','iter=75', 'iter=100','iter=125','iter=150','iter=175','iter=200','iter=300','iter=400','iter=500'], columns = ['DP','DI','MA','SU'])


#index_list is index names and corresponding number of iterations

index_list =[['inter=10',10],['inter=25',25],['inter=50',50],['inter=75',75],['inter=100',100],['inter=125',125],['inter=150',150],['inter=175',175],['inter=200',200],['inter=300',300],['inter=400',400],['inter=500',500]]
#index_list =[['iter=2',100],['iter=5',5]]

# print basic things about the network
# get the edge list first based on num_interactions


initial_states = get_all_objects(all_participants)

print ('no of nodes are:',len(initial_states))
print ('no of edges are:',len(Edges_undirected))
for i in range(len(initial_states)):
    df_SL.at['inter=0',initial_states[i][0]] = initial_states[i][1]
df_SL.at['inter=0','#Changes'] = 0
df_SL.at['inter=0','#H'] = 10
df_SL.at['inter=0','#L'] = 2

for i in range(len(initial_states)):
    df_SS.at['inter=0',initial_states[i][0]] = initial_states[i][2]
df_SS.at['inter=0','#Changes'] = 0
df_SS.at['inter=0','#NC'] = 11
df_SS.at['inter=0','#C'] = 0
df_SS.at['inter=0','#V'] = 1

print("Final Security States are:")
result = all_interactions(Edges_directed,all_participants,df_SL,df_SS,index_list)
print(result[0])
print(result[1])

print("Final States are: ")
final_states = get_all_objects(all_participants)
for each_agent in final_states:
    print(each_agent[0],each_agent[1],each_agent[2])
