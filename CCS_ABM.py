"""
////////////////////////////////////////////////////////////////////////////////////////
//Study Title : A Framework to Assess Cyber-Vulnerabilities of Construction Networks  //
//Authors     : Bharadwaj R.K.Mantha and Borja Garcia de Soto                		  //
//Email       : bmantha at nyu dot edu                                       		  //
//Affiliation : S.M.A.R.T. Construction Research Group,                      		  //
//              Division of Engineering,                                     		  //                 
//			    	New York University Abu Dhabi.                               		  //
//Last updated: June 4, 2020                                                  		  // 
////////////////////////////////////////////////////////////////////////////////////////
"""

# The objective is to simulate the spread of vulnerability in construction networks
# each of the construction entities are represents as agents in the model
# each agent has an initial security state (normal, uncertain, and vulnerable)
# agents interact and change their states based on the rules and conditions 
# inputs are the following
#      agent class (i.e., Project_participants) objects with their id and type (i.e., nodes)
#      connections between agents (i.e., edges)
# outputs are the following
#      summary of nodes and edges in the network
#      security state of each of the agents after performing 0,10,...500 iterations 
# for further details regarding the model, please refer to the paper at (link_to_be_added)

# general imports 
import networkx as nx
import pandas as pd
import numpy, gc 
import matplotlib.pyplot as plt

class construction_agents(object):
    #agent class to define the agents and resp attributes
    # for agent_name abbrevations pls refer to the paper
    # SL - Security Level, High - H and Low - L
    # SS - Security State, Not Compromised - NC,  Compromised - C, and Vulnerable - V
    def __init__(self, agent_name, agent_SL, agent_SS):
        self.agent_name = agent_name
        self.agent_SL = agent_SL
        self.agent_SS = agent_SS

def resetToInitial(list_o,list_d):
    #to reset the updated participant metrics to the original values
    for i in range(len(list_o)):
        list_d[i].SL = list_o[i].SL
        list_d[i].SS = list_o[i].SS
        
def get_all_objects(project_participants):
	# method to get all the instances of the class Project_participants
    result = []
    for each_agent in project_participants:
        temp = []
        #print(obj.participant_id, obj.participant_type)
        temp.append(each_agent.agent_name)
        temp.append(each_agent.agent_SL)
        temp.append(each_agent.agent_SS)
        result.append(temp)
    return result

    
def choose_interaction_CS(Edges, num_interations):
    # outputs list of occurances of edges (=total_iterations) 
    # based on edge_prob  
    Edge_numbers = [i for i in range(len(Edges))]
    edge_probs = get_edge_probs(Edges) #[0.50,0.20,0.20,0.10]
    list_of_edge_numbers = numpy.random.choice(Edge_numbers,num_interations,p=edge_probs)  
    #print(list_of_edge_numbers)
    list_of_interactions = []
    for each_no in list_of_edge_numbers:
        list_of_interactions.append(Edges[each_no])
        #print(Edges[each_no][0].participant_id,Edges[each_no][1].participant_id)
    return list_of_interactions

def get_edge_probs(Edges):
    # gets the probability of each edge based on cs of each edge
    list_of_edge_probs = []
    total_edge_strength = 0
    for each_edge in Edges:
        total_edge_strength = total_edge_strength + each_edge[-1]
    #print(total_edge_strength)
    for each_edge in Edges:
        list_of_edge_probs.append(each_edge[-1]/total_edge_strength)
    #print(list_of_edge_probs)     
    if sum(list_of_edge_probs) != 1:
        print("Sum of Probabilities is not 1 but it is:", sum(list_of_edge_probs))
    return list_of_edge_probs

def getPI(agent1, agent2):
    # method to get the PI based on the SS of interacting agents1 and 2
    # agent1 is the originator agent (i.e., vulnerability spread originator)
    # agent2 is the receiver agent 
    if agent1.agent_SS == 'NC':
        return 0.0
    elif agent1.agent_SS == 'C':
        if agent2.agent_SS == 'NC':
            if agent2.agent_SL == 'H':
                return 0.06
            else:
                return 0.12
        elif agent2.agent_SS == 'C':
            if agent2.agent_SL == 'H':
                return 0.08
            else:
                return 0.16
        elif agent2.agent_SS == 'V':
            return 0.0
    elif agent1.agent_SS == 'V':
        if agent2.agent_SS == 'NC':
            if agent2.agent_SL == 'H':
                return 0.10
            else:
                return 0.20
        elif agent2.agent_SS == 'C':
            if agent2.agent_SL == 'H':
                return 0.25
            else:
                return 0.30
        elif agent2.agent_SS == 'V':
            if agent2.agent_SL == 'H':
                return 0.35
            else:
                return 0.0  
            
def interaction_decision(PI):
    # method to decide if the interaction results in a change of vulnerability state
	# True represents a change and False represents a no change scenario 
    return numpy.random.choice([True, False], 1, p=[PI, 1-PI])[0]

def after_interaction(agents_pair):
	# method that performs the interaction and possible change of states
    agent1 = agents_pair[0]
    agent2 = agents_pair[1]
    if agent1.agent_SS == 'NC':
        pass
    elif agent1.agent_SS == 'C':
        if agent2.agent_SS == 'NC':
            agent2.agent_SS = 'C'
        elif agent2.agent_SS == 'C':
            if agent2.agent_SL == 'H':
                agent2.agent_SL = 'L'
            else:
                agent2.agent_SS = 'V'
        elif agent2.agent_SS == 'V':
            pass
    elif agent1.agent_SS == 'V':
        if agent2.agent_SS == 'NC':
            agent2.agent_SS = 'C'

        elif agent2.agent_SS == 'C':
            if agent2.agent_SL == 'H':
                agent2.agent_SL = 'L'
            else:
                agent2.agent_SS = 'V'
        elif agent2.agent_SS == 'V':
            if agent2.agent_SL == 'H':
                agent2.agent_SL = 'L'
            else:
                pass

    return None

def run_interaction(Edges, num_interactions):
	# method to run the specified number of iterations and perform the interactions 
    Edges_List_CS = choose_interaction_CS(Edges,Edge_numbers,edge_probs,num_interactions)
    for i in range(num_interactions):
        #print('iteration:',i)
        x = Edges_List_CS[i]
        PI = getPI(x[0],x[1])
        if interaction_decision(PI):
            #print('yes')
            after_interaction(x)
        else:
            pass
    return None

def one_iteration(Edges,num_interactions,Project_participants,df,index_name):
	# method that performs one interaction (along with the interaction and possible change of states)
    run_interaction(Edges,num_interactions)
    final_states = get_all_objects(Project_participants)
    for i in range(len(final_states)):
        df.at[index_name,final_states[i][0]] = final_states[i][1]
    #print('states after this iteration are:')
    #print (df)
    return df

def all_interations(Edges,Project_participants,df,index_list):
	# method to run all the iterations mentioned as per the inputted index_list 
    for each_index in index_list:
        one_iteration(Edges,each_index[1],Project_participants,df,each_index[0])
    return df


############################### USER INPUTS ##################################

num_interactions = 10

CO  = construction_agents('CO','H','NC')

SM  = construction_agents('SM','H','NC')

#print(getPI(CO,SM))

MS  = construction_agents('MS','H','NC')
CS  = construction_agents('CS','H','NC')
SS  = construction_agents('SS','H','NC')

EN  = construction_agents('EN','H','NC')

OP  = construction_agents('OP','H','NC')
HE  = construction_agents('HE','L','NC')

DP  = construction_agents('DP','H','NC')
DI  = construction_agents('DI','L','NC')
MA  = construction_agents('MA','H','NC')
SU  = construction_agents('SU','H','V')

CO_o  = construction_agents('CO_o','H','NC')

SM_o  = construction_agents('SM_o','H','NC')

MS_o  = construction_agents('MS_o','H','NC')
CS_o  = construction_agents('CS_o','H','NC')
SS_o  = construction_agents('SS_o','H','NC')

EN_o  = construction_agents('EN_o','H','NC')

OP_o  = construction_agents('OP_o','H','NC')
HE_o  = construction_agents('HE_o','L','NC')

DP_o  = construction_agents('DP_o','H','NC')
DI_o  = construction_agents('DI_o','L','NC')
MA_o  = construction_agents('MA_o','H','NC')
SU_o  = construction_agents('SU_o','H','V')

all_participants_o = [CO_o,SM_o,MS_o,CS_o,SS_o,EN_o,OP_o,HE_o,DP_o,DI_o,MA_o,SU_o]
all_participants = [CO,SM,MS,CS,SS,EN,OP,HE,DP,DI,MA,SU]

Edges_undirected = [
          [CO,SM,4],
          [SM,MS,4],[SM,CS,30],[SM,SS,4],
          [CS,EN,30],[SS,DP,30],
          [EN,OP,30],[EN,HE,30],
          [OP,DP,30],[HE,DP,30],
          [DP,DI,1],[DI,MA,1],[MA,SU,1]
        ]

Edges_directed = [
          [CO,SM,2],[SM,CO,2],
          [SM,MS,2],[MS,SM,2],[SM,CS,15],[CS,SM,15],[SM,SS,2],[SS,SM,2],
          [CS,EN,15],[EN,CS,15],[SS,DP,15],[DP,SS,15],
          [EN,OP,15],[OP,EN,15],[EN,HE,15],[HE,EN,15],
          [OP,DP,15],[DP,OP,15],[HE,DP,15],[DP,HE,15],
          [DP,DI,0.5],[DI,DP,0.5],[DI,MA,0.5],[MA,DI,0.5],[MA,SU,0.5],[SU,MA,0.5]
        ]

edges = [(CO,SM,{'weight':4}),
    (SM,MS,{'weight':4}),(SM,CS,{'weight':30}),(SM,SS,{'weight':4}),
    (CS,EN,{'weight':30}),(SS,DP,{'weight':30}),
    (EN,OP,{'weight':30}),(EN,HE,{'weight':30}),
    (OP,DP,{'weight':30}),(HE,DP,{'weight':30}),
    (DP,DI,{'weight':1}),(DI,MA,{'weight':1}),(MA,SU,{'weight':1})]


############################# CODE IMPLEMENTATION ############################
G = nx.Graph()
G.add_nodes_from(all_participants)

G.add_edges_from(edges)

# Creating an empty Dataframe with column and row names only with NaN as elements
df_SL = pd.DataFrame(index =['iter=0', 'iter=10','iter=25','iter=50','iter=75', 'iter=100','iter=125','iter=150','iter=175','iter=200','iter=300','iter=400','iter=500'], columns = ['CO','SM','MS','CS','SS','EN','OP','HE','DP','DI','MA','SU'])
df_SS = pd.DataFrame(index =['iter=0', 'iter=10','iter=25','iter=50','iter=75', 'iter=100','iter=125','iter=150','iter=175','iter=200','iter=300','iter=400','iter=500'], columns = ['CO','SM','MS','CS','SS','EN','OP','HE','DP','DI','MA','SU'])

#index_list is index names and corresponding number of iterations
index_list =[['iter=10',10],['iter=25',25],['iter=50',50],['iter=75',75],['iter=100',100],['iter=125',125],['iter=150',150],['iter=175',175],['iter=200',200],['iter=300',300],['iter=400',400],['iter=500',500]]

# print basic things about the network
initial_states = get_all_objects(all_participants)
#print(initial_states)

"""
print ('no of nodes are:',len(initial_states))
print ('no of edges are:',len(Edges_undirected))
for i in range(len(initial_states)):
    df_SL.at['iter=0',initial_states[i][0]] = initial_states[i][1]
print(df_SL)

for i in range(len(initial_states)):
    df_SS.at['iter=0',initial_states[i][0]] = initial_states[i][2]
print(df_SS)

#print (all_iterations(Edges,Project_participants,df,index_list))
"""