"""
////////////////////////////////////////////////////////////////////////////////////////
//Study Title : A Framework to Assess Cyber-Vulnerabilities of Construction Networks  //
//Authors     : Bharadwaj R.K.Mantha and Borja Garcia de Soto                		  //
//Email       : bmantha at nyu dot edu                                       		  //
//Affiliation : S.M.A.R.T. Construction Research Group,                      		  //
//              Division of Engineering,                                     		  //                 
//				New York University Abu Dhabi.                               		  //
//Last updated: May 28, 2020                                                		  // 
////////////////////////////////////////////////////////////////////////////////////////
"""

# The objective is to simulate the spread of vulnerability in construction networks
# each of the construction entities are represents as agents in the model
# each agent has an initial security state (normal, uncertain, and vulnerable)
# agents interact and change their states based on the rules and conditions 
# inputs are the following
#      agent class (i.e., Project_participants) objects with their id and type (i.e., nodes)
#      connections between agents (i.e., edges)
# outputs are the following
#      summary of nodes and edges in the network
#      security state of each of the agents after performing 0,10,...500 iterations 
# for further details regarding the model, please refer to the paper at (link_to_be_added)

import numpy, gc 
import numpy.random
from itertools import combinations
import pandas as pd


class Project_participants:
  def __init__(self, participant_id, participant_type):
    self.participant_id = participant_id
    self.participant_type = participant_type

    
def choose_interaction(Edges):
    # this method helps choose an edge in the network at random for the interaction to occur
    temp = numpy.random.randint(0, len(Edges))
    #print('temp is:',temp)
    #print('chosen edge is:',Edges[temp])
    return Edges[temp]


def interaction_decision():
    # method to decide if the interaction results in a change of vulnerability state
	# True represents a change and False represents a no change scenario 
    return numpy.random.choice([True, False], 1, p=[0.05, 0.95])[0] 
    
def after_interaction(list_objects):
	# method that performs the interaction and possible change of states
    if list_objects[0].participant_type == list_objects[1].participant_type:
		# no change in state if both agents have equal security states
        #print('yes')
        pass
    elif list_objects[0].participant_type == 'N':
		# change from N to U 
        list_objects[0].participant_type = 'U'
        
    elif list_objects[0].participant_type == 'U' and list_objects[1].participant_type == 'V':
		# change from U to V 
        list_objects[0].participant_type = 'V'
        
    elif list_objects[0].participant_type == 'U' and list_objects[1].participant_type == 'N':
		# change from N to U 
        list_objects[1].participant_type = 'U'
        
    elif list_objects[0].participant_type == 'V' and list_objects[1].participant_type == 'N':
		# change from N to U 
        list_objects[1].participant_type = 'U'
        
    elif list_objects[0].participant_type == 'V' and list_objects[1].participant_type == 'U':
		# change from U to V 
        list_objects[1].participant_type = 'V'
    return None

def get_all_objects(Project_participants):
	# method to get all the instances of the class Project_participants
    result = []
    for obj in gc.get_objects():
        temp = []
        if isinstance(obj, Project_participants):
            #print(obj.participant_id, obj.participant_type)
            temp.append(obj.participant_id)
            temp.append(obj.participant_type)
        if len(temp) > 0:
            result.append(temp)
    return result

def run_iterations(Edges, num_interactions):
	# method to run the specified number of iterations and perform the interactions 
    for i in range(num_interactions):
        #print('iteration:',i)
        x = choose_interaction(Edges)
        if interaction_decision():
            #print('yes')
            after_interaction(x)
        else:
            pass

def one_iteration(Edges,num_interactions,Project_participants,df,index_name):
	# method that performs one iteration (along with the interaction and possible change of states)
    run_iterations(Edges,num_interactions)
    final_states = get_all_objects(Project_participants)
    for i in range(len(final_states)):
        df.at[index_name,final_states[i][0]] = final_states[i][1]
    #print('states after this iteration are:')
    #print (df)
    return df

def all_iterations(Edges,Project_participants,df,index_list):
	# method to run all the iterations mentioned as per the inputted index_list 
    for each_index in index_list:
        one_iteration(Edges,each_index[1],Project_participants,df,each_index[0])
    return df

def choose_interaction_CS(Edges, Edge_numbers, edge_probs, total_iterations):
     list_of_edge_numbers = numpy.random.choice(Edge_numbers,total_iterations,p=edge_probs)  
     print(list_of_edge_numbers)
     list_of_interactions = []
     for each_no in list_of_edge_numbers:
         list_of_interactions.append(Edges[each_no])
         print(Edges[each_no][0].participant_id,Edges[each_no][1].participant_id)
     return list_of_interactions
def get_edge_probs(Edges):
    list_of_edge_probs = []
    total_edge_strength = 0
    for each_edge in Edges:
        total_edge_strength = total_edge_strength + each_edge[-1]
    print(total_edge_strength)
    for each_edge in Edges:
        list_of_edge_probs.append(each_edge[-1]/total_edge_strength)
    print(list_of_edge_probs)
    return list_of_edge_probs


#################### INPUTS ####################################
    
######## NOTE: Probability input in the interaction_Decision()##############
    
# N - Normal State; U - Uncertain_State; V-Vulnerable_State 
# first input to the class Project_participants is Agent ID and second is security state
CO  = Project_participants('CO','N')

SM  = Project_participants('SM','N')

PR  = Project_participants('PR','N')
OI  = Project_participants('OI','N')
CS  = Project_participants('CS','N')

EN  = Project_participants('EN','N')

OP  = Project_participants('OP','N')
HE  = Project_participants('HE','V')

DP  = Project_participants('DP','N')
SU  = Project_participants('SU','N')
MA  = Project_participants('MA','N')
DI  = Project_participants('DI','N')

# define edges or connections that exist between the partitipants (agents)
Edges = [
          [CO,SM,1],
          [SM,PR,2],[SM,OI,3],[SM,CS,4]
        ]

"""
Edges = [
          [CO,SM,'1'],
          [SM,PR,'1'],[SM,OI.'1'],[SM,CS,'1'],
          [PR,OI],[PR,DI],[OI,DP],[CS,EN],
          [EN,OP],[EN,HE],
          [OP,DP],[HE,DP],
          [SU,MA],[MA,DI],[DI,DP]
        ]
"""
Edge_numbers = [i for i in range(len(Edges))]
total_iterations = 10
edge_probs = get_edge_probs(Edges) #[0.50,0.20,0.20,0.10]

# Creating an empty Dataframe with column and row names only with NaN as elements
df = pd.DataFrame(index =['iter=0', 'iter=10','iter=25','iter=50','iter=75', 'iter=100','iter=125','iter=150','iter=175','iter=200','iter=300','iter=400','iter=500'], columns = ['CO','SM','PR','OI','CS','EN','OP','HE','DP','DI','MA','SU'])
#index_list is index names and corresponding number of iterations
index_list =[['iter=10',10],['iter=25',25],['iter=50',50],['iter=75',75],['iter=100',100],['iter=125',125],['iter=150',150],['iter=175',175],['iter=200',200],['iter=300',300],['iter=400',400],['iter=500',500]]

#################### MAIN LOOP ####################################
# print basic things about the network
initial_states = get_all_objects(Project_participants)
print ('no of nodes are:',len(initial_states))
print ('no of edges are:',len(Edges))
for i in range(len(initial_states)):
        df.at['iter=0',initial_states[i][0]] = initial_states[i][1]

#print (all_iterations(Edges,Project_participants,df,index_list))


choose_interaction_CS(Edges,Edge_numbers,edge_probs,total_iterations)

